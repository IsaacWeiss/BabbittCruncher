Twelve-tone serialism is a method of composition designed to ensure that every pitch class is used exactly as frequently as every other pitch class. At the core of a serialist work is its initial tone row, a predetermined ordering of the twelve pitch classes, which can then be transposed, inverted, and retrograded to create new tone rows. The twelve transpositions of the four transformations (prime form, retrograde, inversion, and retrograde inversion) yield a total of 48 possible variations of the row, all of which can be read from a 12*12 matrix called a Babbitt square, after Milton Babbitt.

Babbitt, among other serialist composers, made use of hexachordal combinatoriality—a property of some tone rows that allows a six-note half of the row to combine with a six-note half of one of its transformations and form a new complete row. Among the various ways combinatoriality can exist, one of the most interesting is that between a row and one of its transposed inversions. The row he uses in the first of his Three Compositions for Piano, { Bb Eb F D C C# G B F# A G# E }, has this property in at least two places: first, HexA (the first hexachord) in I1 (the inversion in its first transposition), { B F# E G A G# }, combines with HexA in P0 (the prime form in its zeroth transposition), { Bb Eb F D C C# }, and the same is true of I2 with P1, and all other transpositions; and second, HexB in I7 { G# E A F# G B } combines with HexA in P0 { Bb Eb F D C C# }, and the same is true of I8 with P1, and all other transpositions.

Only a limited number of tone rows have this property. How did Babbitt and other serialists find ones that did?

That question motivated the BabbittCruncher project.

I must begin by stating that I suspect that there is some common attribute of tone rows with inversional combinatoriality that is visible in the original form of the row, but I have been unable to identify what it is. Therefore, it is possible that all my work has been redundant, and a superior solution exists. That said: how else might one discover whether a row is combinatorial or not? Only through trial and error. Doing so by hand is almost unimaginable; even if some early serialists did so that way, with modern technology there’s no reason not to set a computer to do those trials swiftly and automatically. So that is what I did.

My BabbitCruncher is, as of version 1.0, a console-only, text-based program that receives a twelve-tone row as input and gives as output the complete Babbitt square and a list of the inversions, if any, that can combine with the prime form. It finds these via a brute force algorithm: it literally tests both hexachords of every inversion against the prime form to determine whether they are combinatorial. This solution is likely not optimal, but it works.

With this much completed, it should be possible to extend the program to automatically generate and test all possible twelve-tone rows and return a list of which ones have the potential for inversional hexachordal combinatoriality. It could also be extended to test for other kinds of combinatoriality. However, given my doubts as to whether the current model is the most efficient, I decided that this working prototype goes far enough.

A Mac executable is provided at https://github.com/IsaacWeiss/BabbittCruncher/releases.
